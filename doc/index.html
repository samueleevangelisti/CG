<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Relazione</title>
</head>
<body>
  <h1>Introduzione</h1>
  Il codice implementa un'applicazione web per la visualizzazione di oggetti 3D illuminati.<br>
  Lo scopo dell'applicazione è la visualizzazione e l'interazione con gli oggetti. Infatti è possibile modificare i parametri della visuale (per esempio langolo di visuale e la posizione dell'osservatore), i parametri della luce (per esempio la posizione della fonte di luce e il colore della luce) e infine i parametri pripri di ogni oggetti (per esempio la posizione, la rotazione, la texture e i parametri relativi al materiale).<br>
  Nell'implementazione della demo è presente un fonte di luce bianca, tre oggetti caricati da file e gli assi cartesiani.<br>
  Gli oggetti caricati sono:
  <ul>
    <li>Un parallelogramma con la base inferiore aperta, con texture di erba e terra, per rappresentare un piano;</li>
    <li>Un cubo, con texture di marmo e logo WebGL;</li>
    <li>Una sfera, senza texture ma colorata in rosso, con i parametri di illuminazione per simulare plastica lucida.</li>
  </ul>
  Gli assi cartesiani sono:
  <ul>
    <li>Rosso per l'asse x;</li>
    <li>Verde per l'asse y;</li>
    <li>Blu per l'asse z.</li>
  </ul>
  Gli assi cartesiani sono resi visibili in quanto l'applicazione vuole essere una sorta di visualizzatore di oggetti, quasi a scopo didattico, quindi può essere utile avere a disposizione un riferimento sull'orientamento della visuale e sulla correttezza nel posizionamento degli oggetti.<br>
  Per la realizzazione dell'applicazione sono state utilizzati:
  <ul>
    <li>WebGL (HTML5, CSS, canvas con contesto webgl);</li>
    <li>JavaScript;</li>
    <li>OpenGL ES SL;</li>
    <li>libreria m4.js e dipendenze;</li>
    <li>Bootstrap.</li>
  </ul>

  <h1>Interfaccia</h1>
  L'interfaccia è divisa in due sezioni, il visualizzatore e il pannello di controllo. Grazie all'utilizzo di Bootstrap, il pannello di controllo si posiziona a destra del visualizzatore quando lo spazio è sufficiente, come nel caso dei pc desktop o tablet, mentre si posiziona sotto il visualizzatore quando lo spazio non è sufficiente, come nel caso degli smartphone.
  <h2>Visualizzatore</h2>
  Il visualizzatore è implementato tramite una canvas HTML5 con contesto grafico webgl. La struttura è minimale e tutto il codice per rendere a schermo gli oggetti è riportato all'interno dei due script "vertex-shader" e "fragment-shader" all'interno del file project/index.html.
  <h2>Pannello di controllo</h2>
  Il pannello di controllo è implementato tramite una lista di expansion panel in mutua esclusione. All'interno degli expansion panel è possibile modificare vari parametri. In ordine vengono prima presentati gli expansion panel di carattere generale e successivamente gli expansion panel relativi agli oggetti mostrati dal visualizzatore. Gli expansion panel sono:
  <ul>
    <li>View: parametri relativi all'osservatore, influiscono sulla resa prospettica;
      <ul>
        <li>fovy: angolo i visuale relativo all'asse y;</li>
        <li>near: distanza minima di visibilità un punto;</li>
        <li>far: distanza massima di visibilità un punto;</li>
        <li>distance: distanza dal punto di osservazione;</li>
        <li>theta: angolo dell'osservatore sul piano xy rispetto all'asse x;</li>
        <li>pi: angolo dell'osservatore sul piano xz rispetto all'asse z;</li>
        <li>target: obiettivo della visualizzazione in coordinate x, y, z (non modificabile);</li>
        <li>view up: normale della visuale in coordinate x, y, z (non modificabile);</li>
        <li>camera: posizione dell'osservatore in coordinate x, y, z (non modificabile, dipende dagli altri parametri).</li>
      </ul>
    </li>
    <li>Light: parametri relativi alla luce, influiscono sull'illuminazione;</li>
      <ul>
        <li>light position: posizione della fonte di luce nello spazio tridimensionale in coordinate x, y, z;</li>
        <li>light color: colore della luce proveniente dalla fonte luminosa in notazione rgba;</li>
        <li>light ambient: TODO DSE bisogna calcolarla partendo dal colore della luce.</li>
      </ul>
    <li>Texture: è possibile caricare fino a 10 file di texture. Ogni texture viene precompilata con un colore blu uniforme che resta tale in caso non venga specificato il file oppure nel caso il file specificato non esista. Prima vengono caricate le texture specificate nell'array <span style="font-family: monospace;">globals.textureSourceArr</span>, poi vengono caricate le texture prese dai file in formato <span style="font-family: monospace;">mtl</span> caricati come dipendenza dei rispettivi file in formato <span style="font-family: monospace;">obj</span>, infine è possibile caricare nuove texture durante l'esecuzione dell'applicazione web;</li>
    <li>Items: gli elementi vengono generati partendo da una struttura ad hoc che ne definisce le caratteristiche spaziali e di texture. È possibile definire traslazioni e rotazioni degli oggetti, in questo modo ogni singolo oggetto può essere definito con coordinate comode al programmatore e successivamente posizionato e ruotato correttamente. Le rotazioni sono effettuate prendendo come centro il baricentro dell'oggetto. Da implementazione non è possibile scalare gli oggetti. Gli elementi possono anche essere caricati da file in formato <span style="font-family: monospace;">obj</span>, in questo caso verrà generato un oggetto conforme alla struttura definita dell'applicazione web. Se il file importa un secondo file in formato <span style="font-family: monospace;">mtl</span>, i parametri relativi al materiale dell'oggetto verranno caricati, altrimenti verranno impostati i parametri di default. Nel caso il secondo file non importi nessuna texture, si considera il parametro "Kd" come colore dell'oggetto e si da al parametro "Kd" il valore massimo in modo da non influire nel calcolo della luminosità diffusa. In caso di presenza di texture, verrà generato un oggetto per ogni texture. Questo deriva dal fatto che texture differenti potrebbero rappresentare materiali differenti, quindi dividendo l'oggetto in più oggetti sarà possibile definire parametri di colorazione specifici per ogni texture. Gli oggetti della demo vengono caricati tutti da file in formato <span style="font-family: monospace;">obj</span>. Ogni oggetto ha dei parametri nascosti che identificano l'indice di inizio e l'indice di fine dei propri valori all'interno dei buffer, in questo modo è possibile impostare i valori propri dell'oggetti, renderizzare tutti i suoi punti e superfici e procedere con l'elemento successivo;</li>
      <ul>
        <li>is flat: true se l'oggetto è composto di superfici piatte, false se le superfici vanno arrotondate. Questo parametro influisce anche sull'illuminazione in quanto se l'oggetto è composto di superfici piatta allora per ogni faccia si considera la normale della superficie, mentre se l'oggetto va smussato si utilizza il Phong shading;</li>
        <li>material emissive: Ke in formato rgb;</li>
        <li>material ambient: Ka in formato rgb;</li>
        <li>material diffuse: Kd in formato rgb;</li>
        <li>material specular: Ks in formato rgb;</li>
        <li>shininess: esponente nel calcolo della luce riflessa;</li>
        <li>opacity: opacità generale del colore;</li>
        <li>texture: texture applicata, indice nella lista all'interno dell'expation panel "Texture";</li>
        <li>x traslation: traslazione lungo l'asse x;</li>
        <li>y traslation: traslazione lungo l'asse y;</li>
        <li>y traslation: traslazione lungo l'asse z;</li>
        <li>y rotation: gradi di rotazione intorno all'asse y;</li>
        <li>z rotation: gradi di rotazione intorno all'asse z;</li>
        <li>x rotation: gradi di rotazione intorno all'asse x;</li>
      </ul>
  </ul>

  <h1>Struttura</h1>
  A livello di root sono presenti i file con le funzionalità implementate per il progetto:
  <ul>
    <li>index.html: pagina html contenente l'implementazione dell'interfaccia statica e i codici  dei due shader;</li>
    <li>globals.js: variabili globali, utile a garantire l'accesso da qualsiasi script dell'applicazione web;</li>
    <li>logUtils.js: log personalizzati;</li>
    <li>ajaxUtils.js: chiamate ajax implementate tramite api fetch nativa;</li>
    <li>utils.js: funzioni di utilità generale</li>
    <li>meshLoader.js: funzioni per parsing di un file in formato <span style="font-family: monospace;">obj</span> e caricamento dell'elemento relativo;</li>
    <li>setters.js: funzioni per il settaggio dei valori, garantisce la conformità tra interfaccia grafica e variabili globali;</li>
    <li>handlers.js: handler degli eventi dell'interfaccia grafica;</li>
    <li>graphicUtils.js: funzioni di utilità per la generazione degli elementi HTML dell'interfaccia grafica;</li>
    <li>main.js: script principale che si occupa di inizializzare l'applicazione ed eseguire il rendering;</li>
  </ul>
  Il codice di alcune funzioni è stato preso direttamente dai codici visti a lezione.

  <h1>Esecuzione del codice</h1>
  L'esecuzione del codice è principalmente visibile analizzando il codice del file main.js e dei due shader. In breve si analizza l'esecizione del codice.
  <h2>main.js</h2>
  Il codice viene eseguito una volta caricata la pagina, quidi all'evento load della window.
  <ul>
    <li>Viene configurata l'interfaccia in modo da adattare la dimensione di visualizzatore e pannello di controllo alle dimensioni dello schermo;</li>
    <li>Si inizializza il contesto grafico e viene popolato l'array contenente le variabili che identificano le texture all'interno dello shader program;</li>
    <li>Vengono popolati li array contenenti i path dei file di texture e gli elementi definiti direttamente da programma;</li>
    <li>Si effettua il parsing dei file contenenti gli oggetti da caricare all'interno del programma, questa operazione carica i diversi file parallelamente e per ogni file restituisce diverse strutture dati che rappresentano la definizione geometrica, la definizione della texture e del materiale e le configurazioni aggiuntive inserie in fase di caricamento;</li>
    <li>Una volta che tutti i file sono stati caricati e parsati, si analizzano le strutture citate in precedenza per generare gli oggetti propri del programma che rappresentano gli elementi desiderati. In questa fase vengono anche calcolate le normali delle superfici e le normali sui singoli vertici analizzando le facce che contengono i vari vertici;</li>
    <li>Vengono generati gli array che saranno trasformati in buffer all'interno dello shader program, i valori vengono presi dagli oggetti che rappresentano gli elementi caricati in precedenza:</li>
      <ul>
        <li>vertexArr: vertici dei vari elementi;</li>
        <li>surfaceNormalArr: normale relativa alla superfice;</li>
        <li>normalArr: normale del vertice calcolata considerando le superfici che contengono il vertice;</li>
        <li>colorArr: array dei colori;</li>
        <li>textureArr: array con le posizioni delle texture;</li>
      </ul>
    <li>Vengono creati dinamicamente gli elementi dell'interfaccia relativi alle texture e agli elementi caricati;</li>
    <li>Vengono settati tutti i parametri, nel caso delle texture, quando viene inserito il path di un file, questo viene subito caricato come texture all'interno dello shader program;</li>
    <li>Vengono estrette e impostate tutte le variabili dello shader program</li>
    <li>Viene eseguita la funziona di render che ad ogni animation frame calcola nuovamente tutti i valori variabili all'interno dell'algoritmo di rendering e disegna i punti e le suerfici definiti.</li>
  </ul>
  <h2>vertex-shader</h2>
  Come da standard viene calcolata posizione del punto applicando la matrice di proiezione, la matrice di vista e la matrice di modifica del modello. In aggiunta vengono passati al fragment shader:
  <ul>
    <li>lightDirection: inverso della distanza tra la fonte di luce e il punto da illuminare, identifica la direzione della luce in relazione alla superfice;</li>
    <li>fragmentSurfaceNormal: si applicano le rotazioni dell'elemento alle normali delle superfici;</li>
    <li>fragmentNormal: si applicano le rotazioni dell'elemento alle normali dei vertici;</li>
    <li>fragmentColor: colore da assegnare;</li>
    <li>fragmentTexture: posizione del punto all'interno della texture da applicare.</li>
  </ul>
  <h2>fragment-shader</h2>
  Per determinare il colore di un punto vengono prese in considerazione le quattro componenti della luce e l'opacità generale del colore. Inoltre l'applicazione dell'illuminazione è abilitabile o disabilitabile tramite la variabile isLight. Infatti il visualizzatore mostra gli assi cartesiani a cui non non viene applicata l'ulluminazione ma semplicemente il proprio colore in maniera uniforme. Per il calcolo delle componenti della luce vengono normalizzati i vettori relativi a direzione della luce, posizione dell'osservatore e normali; successivamente si identifica quale normale utilizzare, se quella relativa alla superfice oppure relativa al vertice; si verifica se il punto è in luce o in ombra e si calcola il colore del pixel prendendoo dalla texture o dal colore definito; per il calcolo della luce:
  <ul>
    <li>emissive: è semplicemente Ke;</li>
    <li>ambient: è calcolato in base a Ka, al colore assegnato e alla luce ambientale;</li>
    <li>diffuse: se il punto è in luce, si segue il calcolo del modello di Phong visto a lezione, altrimenti viene azzerato;</li>
    <li>specular: se il punto è in luce, si segue il calcolo del modello di Phong visto a lezione, altrimenti viene azzerato;</li>
    <li>opacityColor: viene presa l'opacità dal colore asegnato e mediata per l'opacità definita da interfaccia;</li>
  </ul>
</body>
</html>
